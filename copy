#!/usr/bin/env ruby
# encoding: utf-8

Version='1.05'
MYNAME = 'copy'

<<'DOC'
= copy - copy from scanner to pdf or image file(s)

= Synopsis
copy [options]	

= Description
copy scans an image, or multiple images, and either prints those, or generates
one or more images files, or a PDF file with one or more images, one per page.
Many options are available to influence brightness, contrast, pixel density, 
color mode, image quality, rotation, page position and size, and more.

copy, without |--outfile| and |--interactive| scans a
sheet and prints it. With |--multi|, multiple images or a multi-page pdf
document are produced.

With |--interactive|, a PDF file is produced, which is viewed using |vpp|
and can printed with |vpp|'s facilities.

With |--outfile=S|, JPEG images are generated, named |S.jpg|, or, if
|--multi| is used, |S01.jpg, S02.jpg, ...|

= Options
Device option:
--device=N	
	set the device to N

Brightness, Contrast, density options:
-b,--brightness=PCT	
	set brightness correction to |PCT| percent (default: 0)
-c,--contrast=PCT	
	set contrast correction to |PCT| percent (default: 0)
-d,--density=INT	
	set contrast correction to |INT| dpi (default: 300)
	
Color mode options:
-C,--color		
	Color mode (the default)
-G,--gray		
	Gray instead of Lineart mode
-L,--lineart		
	Lineart instead of Color mode
	
Positioning options:
-l,--left=MM		
	set left offset to |MM| mm (default: 0)
-t,--top=MM		
	set top offset to |MM| mm (default: 0)
-x,--x=MM		
	set width to |MM| mm (default: 210)
-y,--y=MM		
	set height to |MM| mm (default: 296.9)
-B,--cd-back		
	back of jewelbox (137x117+3+3)
-F,--cd-front		
	front of jewelbox (119x117+3+17))
-D,--cd-disk		
	CD disk (120x120+0+0)
	
Output options:
-o,--outfile=STRING	
	set output filename to |STRING| (default: nil)
   --imagetype=STRING	
	set image type to |STRING|; default: jpg;
	available are: jpg, png, gif, tiff, ppm, pgm, pbm
-n,--number=COPIES	
	make |COPIES| copies, if printing (default: 1)
	
Conversion & Interaction options:
-m,--multi	
	keep scanning, incrementing |--outfile| or adding pdf pages
-q,--quality=PERCENT	
	jpg conversion quality (%, default 75)
-r,--rotate=DEGREES	
	rotate |DEGREES| degrees clockwise (0, 90, 180 or 270 only)
-v,--verbose	
	be verbose
-i,--interactive	
	print interactively
-h,--help	
	print this help
-e,--examples	
	show some examples of use

= Author and copyright
Author	Wybo Dekker
Email	U{Wybo@dekkerdocumenten.nl}{wybo@dekkerdocumenten.nl}
License	Released under the U{www.gnu.org/copyleft/gpl.html}{GNU General Public License}
DOC

require 'optparse'
require 'ostruct'

# This should eventually go to a config file
DEVICES = [
   OpenStruct.new(
      :device  => 'epkowa',
      :name    => 'Epson V350',
      :Lineart => 'Binary',
      :Gray    => 'Gray',
      :Color   => 'Color',
      :xmax    => 215.9,
      :ymax    => 297.18,
      :xdpi    => [100,200,300,400,600,800,1200,2400,4800],
      :ydpi    => [100,200,300,400,600,800,1200,1600,2400,3600,4800,6600,9600],
      :hasxy   => true
   ),
   OpenStruct.new(
      :device  => 'canon_dr',
      :name    => 'Canon DR2080C',
      :Lineart => 'Lineart',
      :Gray    => 'Gray',
      :Color   => 'Color',
      :xmax    => 215.872,
      :ymax    => 279.364,
      :xdpi    => [100,150,200,240,300,400,600],
      :ydpi    => [100,150,200,240,300,400,600],
      :hasxy   => false
   ),
   OpenStruct.new(
      :device  => 'hpaio',
      :name    => 'HP Photosmart C4500',
      :Lineart => 'Binary',
      :Gray    => 'Gray',
      :Color   => 'Color',
      :xmax    => 215.9,
      :ymax    => 297.18,
      :xdpi    => [100,200,300,400,600,800,1200,2400,4800],
      :ydpi    => [100,200,300,400,600,800,1200,1600,2400,3600,4800,6600,9600],
      :hasxy   => true
   ),
] 

module FileTest
   def FileTest.exec_in_path?(name)
      ENV['PATH'].split(/:/).each {|v|
         @x = Dir[v + '/' + name]
         if @x.size>0 && FileTest.executable?(@x[0])
            return true
         end
      }
      return false
   end

   def FileTest.missing(*names)
      missing = []
      names.each { |v|
         FileTest.exec_in_path?(v) or missing.push(v)
      }
      fail(RuntimeError,
          "Missing executable#{missing.size > 1 ? 's' : '' } (#{missing.join(', ')})",
           File.basename($0)) if missing.size > 0
   end
end # FileTest

def sys(command)
   puts command.strip.squeeze('a ') if ::VERBOSE
   system command or exit(1)
end

def scan(op,dir,file)
   file =~ /^\// or file = "#{dir}/#{file}"
   command = <<-EOF
      scanimage \
      --device=#{op.device.device} \
      --#{op.device.hasxy ? 'x-' : ''}resolution #{op.density} \
      --#{op.device.hasxy ? 'y-' : ''}resolution #{op.density} \
      --mode #{op.mode} \
      -l #{op.left} \
      -t #{op.top} \
      -x #{op.x} \
      -y #{op.y} >#{file}.ppm
   EOF
   puts command if op.verbose
   Signal.trap('INT') { puts "\nCan't interrupt!!" }
   sys command
   sys("exiftool -comment='' -overwrite_original_in_place  #{file}.ppm >/dev/null")
   flags = "-rotate #{op.rotate}"
   unless op.imagetype == 'ppm'
      sys <<-EOF
           convert -quality #{op.quality} \
		   -density #{op.density} \
                   -brightness-contrast #{op.brightness} \
                   #{file}.ppm #{flags} #{file}.#{op.imagetype}
           rm #{file}.ppm
      EOF
   end
end

# defaults:
op = OpenStruct.new(
  :brightness  => 0,
  :contrast    => 0,
  :density     => 300,
  :device      => DEVICES[0],
  :imagetype   => 'jpg',
  :interactive => false,
  :left        => 0,
  :maxx        => DEVICES[0].xmax,
  :maxy        => DEVICES[0].ymax,
  :mode        => DEVICES[0].Color,
  :multi       => false,
  :n           => 1,
  :name        => DEVICES[0].name,
  :outfile     => nil,
  :quality     => 75,
  :rotate      => 0,
  :top         => 0,
  :verbose     => false,
  :x           => [DEVICES[0].xmax,210].min,
  :y           => [DEVICES[0].ymax,297].min,
)

OptionParser.new do |opt|
    opt.banner =  "This is copy version #{Version}: copy from scanner to pdf or image(s)\n\n"
    opt.banner << "Usage: #{MYNAME} [--device=n]  [other options]\n\n"
    opt.banner << "With --outfile=S, JPEG images are generated\n"
    opt.banner << "Without --outfile, a (multipage) pdf is produced which,\n"
    opt.banner << "   with --multi, can interactively be printed"
    opt.separator ""
    opt.separator "Scan device"
    opt.on('--device N',Integer,
                "set the scan device number; the default is 0 (#{op.name})"
          ) do |v|
               v.between?(0,DEVICES.size-1) or
                  fail(ArgumentError,"the device number must be between 0 and #{DEVICES.size-1}")
               d = DEVICES[v]
               op.device = d
               op.name   = d.name
               op.x      = [d.xmax,210].min
               op.y      = [d.ymax,297].min
               op.mode   = d.Color
               op.maxx   = d.xmax
               op.maxy   = d.ymax
            end
    opt.separator ""
    opt.separator "Brightness, Contrast, density options"
    opt.on('-b','--brightness PCT', Integer,
                "set brightness correction to PCT percent (default: #{op.brightness})"
          ) do |v|
               v.between?(-100,100) or
                  fail(ArgumentError,"brightness must be between -100 and 100",::MYNAME)
               op.brightness = v
            end

    opt.on('-c','--contrast PCT',   Integer,
                "set contrast correction to PCT percent (default: #{op.contrast})"
          ) do |v|
               v.between?(-100,100) or
                  fail(ArgumentError,"contrast must be between -100 and 100",::MYNAME)
               op.contrast = v
            end

    opt.on('-d','--density INT',   Integer,
                "set contrast correction to INT dpi (default: #{op.density})"
          ) do |v|
               op.device.xdpi.include?(v) or
                  fail(ArgumentError,"density must be in #{op.device.xdpi.inspect} dpi",::MYNAME)
               op.density = v
            end

    opt.separator ""
    opt.separator "Color mode options"
    opt.on('-C','--color',
                'Color mode (the default)'
          ) do
               op.mode = op.device.Color
            end

    opt.on('-G','--gray',
                'Gray instead of Color mode'
          ) do
               op.mode = op.device.Gray
            end

    opt.on('-L','--lineart',
                'Lineart instead of Color mode'
          ) do |v| op.mode = op.device.Lineart
            end

    opt.separator ""
    opt.separator "Positioning options"
    opt.on('-l','--left MM', Integer,
                "set left offset to MM mm (default: #{op.left})"
          ) do |v| op.left = v end

    opt.on('-t','--top MM', Integer,
                "set top offset to MM mm (default: #{op.top})"
          ) do |v| op.top = v end

    opt.on('-x','--x MM', Integer,
                "set width to MM mm (default: #{op.x})"
          ) do |v| op.x = [v,op.maxx].min end

    opt.on('-y','--y MM', Integer,
                "set height to MM mm (default: #{op.y})"
          ) do |v| op.y = [v,op.maxy].min end

    opt.on('-B','--cd-back',
                'back of jewelbox'
          ) do
              op.x = 137;
              op.y = 117;
              op.top = 3;
              op.left = 3;
              op.outfile = 'back';
              op.mode = op.device.Color
            end

    opt.on('-F','--cd-front',
                'front of jewelbox'
          ) do
              op.x = 119;
              op.y = 117;
              op.top = 3;
              op.left = 17;
              op.outfile = 'front';
              op.mode = op.device.Color
            end

    opt.on('-D','--cd-disk',
                'CD-disk'
          ) do
              op.x = 120;
              op.y = 120;
              op.top = 0;
              op.left = 0;
              op.outfile = 'disk';
              op.mode = op.device.Color
            end

    opt.separator ""
    opt.separator "Output options"
    opt.on('-o','--outfile=STRING',String,
               'set output filename to STRING (default: nil)'
          )  do |v| op.outfile = v end

    opt.on(     '--imagetype=STRING',String,
               'set image type to STRING'
          )  do |v| op.imagetype = v
                v =~/^(png|jpg|ppm|gif|pgm|pbm|tiff)$/ or
                   raise(RuntimeError,"Unknown image type #{v}")
             end

    opt.on('-n','--number COPIES', Integer,
                'make COPIES copies, if printing (default: 1)'
          ) do |v| op.n = v end

    opt.separator ""
    opt.separator "Conversion & Interaction options"
    opt.on('-m','--multi',
                'keep scanning, incrementing --outfile or adding pdf pages'
          ) do op.multi = true  end

    opt.on('-q','--quality PERCENT', Integer,
                "jpg conversion quality (%, default #{op.quality})"
          ) do |v| op.quality = v end

    opt.on('-r','--rotate DEGREES', Integer,
                'rotate DEGREES degrees clockwise'
          ) do |v|
              v = v.to_i
              unless [0,90,180,270].include?(v)
                puts "--rotate option argument must be 0, 90, 180, or 270"
                exit 1
              end
              op.rotate = v
            end

    opt.on('-v','--verbose',
                'be verbose'
          ) do |v| op.verbose = true end

    opt.on('-V','--version',
                'print version and exit'
          ) do
               puts opt.version
               exit
            end

    opt.on('-i','--interactive',
                'print interactively'
          ) do |v| op.interactive = true end

    opt.on('-h','--help',
                'print this help and exit'
          ) do
               puts opt.to_s.sub(/^ *-I\n/,'')
               exit
            end
    opt.on('-e','--examples','show some examples of use') do
            puts <<-EOD
            copy a page to the printer:
                copy
            copy multiple pages in gray mode and print (or save as pdf) the result interactively:
                copy -Gmi
            create serveral colored JPEG images in testnn.jpg:
                copy -Cmo test
            EOD
            exit(0)
            end
    opt.on('-I') do system("instscript --markdown #{MYNAME}"); exit; end
end.parse!

ARGV.size >0 and raise(ArgumentError,"Unexpected arguments: #{ARGV}\n",'copy')
WORKDIR = Dir.getwd
FileTest.missing('scanimage','convert')
VERBOSE = op.verbose

count, file, dir = 1, 'f01', '.'
if op.outfile
   file = op.outfile
   file << '01' if op.multi
else
   FileTest.missing('mk','vpp')
   dir = "/tmp/#{MYNAME}-#{$$}"
   Dir.mkdir(dir)
   [0,1,2,15].each do |s|
      Signal.trap(s) do
         Dir["#{dir}/*"].each { |d| File.unlink(d) }
         Dir.rmdir(dir)
      end
   end
end

loop {
   if count >1
      str = ''
      str = " for scan #{count}" if op.multi
      print "Scanner ready#{str}? (n to stop) "
      STDOUT.flush
      break if gets.chomp == 'n'
   end
   scan(op,dir,file)
   break unless op.multi
   file = file.next
   count += 1
}

unless op.outfile
   w,h =  op.x, op.y
   w,h =  h,w if [90,270].include?(op.rotate)

   tex = open("#{dir}/main.tex",'w')
   tex.print <<-EOF
   \\documentclass{article}
   \\usepackage[margin=0pt,paperwidth=#{w}mm,paperheight=#{h}mm]{geometry}
   \\parindent0pt\\parskip0pt
   \\usepackage{graphicx}
   \\pagestyle{empty}
   \\begin{document}
   EOF

   Dir["#{dir}/*."+op.imagetype].sort.each { |f|
      tex.puts "\\includegraphics[height=.999\\paperheight,width=.999\\paperwidth]{#{f}}\\eject"
   }
   tex.puts '\end{document}'
   tex.close

   flags = (VERBOSE ? '--verbose' : '')

   sys("VPPCHECKSAVED=1 mk #{dir}/main #{flags}")
end
